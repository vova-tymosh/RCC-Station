<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>RCC MQTT Data Plotter | JMRI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: #f5f7fa;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: flex;
            gap: 20px;
        }

        .sidebar {
            width: 200px;
            flex-shrink: 0;
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }

        .loco-panel,
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .loco-panel h3,
        .control-panel h3 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 16px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .loco-item {
            display: block;
            margin: 0 0 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            transition: all 0.2s;
            cursor: pointer;
        }

        .loco-item:hover {
            border-color: #667eea;
            transform: translateX(3px);
        }

        .loco-item.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .loco-item.selected .loco-name {
            color: white;
        }

        .loco-item.selected .loco-details {
            color: rgba(255, 255, 255, 0.9);
        }

        .loco-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 6px;
            vertical-align: middle;
        }

        .loco-name {
            font-weight: 600;
            color: #333;
            font-size: 14px;
            display: inline;
        }

        .loco-details {
            font-size: 11px;
            display: block;
            color: #666;
            margin-top: 4px;
        }

        .throttle-container {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            margin: 10px 0 15px 0;
            position: relative;
        }

        .throttle-slider {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
            width: 8px;
            height: 120px;
            background: linear-gradient(to top, #667eea, #764ba2);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .throttle-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: white;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #667eea;
        }

        .throttle-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: white;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid #667eea;
        }

        .throttle-value {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            min-width: 45px;
            text-align: left;
            position: absolute;
            left: 15px;
        }

        .direction-buttons {
            display: flex;
            flex-direction: row;
            gap: 5px;
            width: 100%;
            justify-content: space-between;
        }

        .dir-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s;
            text-align: center;
        }

        .dir-btn:hover {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .dir-btn:active {
            transform: scale(0.95);
        }

        .dir-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-color: #667eea;
            color: white;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 20px;
        }

        .chart-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .chart-title {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 2px solid #f0f0f0;
        }

        .chart-container {
            position: relative;
            height: 250px;
        }

        @media (max-width: 768px) {
            .charts-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>üöÇ RCC MQTT Data Plotter</h1>
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="loco-panel">
                <h3>üöÇ Locomotives</h3>
                <div id="locoList">
                    <em style="color: #999;">Waiting...</em>
                </div>
            </div>

            <div class="control-panel">
                <h3>üéÆ Controls</h3>
                <div id="controlsContent">
                    <em style="color: #999;">Select a locomotive</em>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="charts-grid">
                <div class="chart-card">
                    <h4 class="chart-title">‚ö° Speed & Throttle</h4>
                    <div class="chart-container"><canvas id="speedChart"></canvas></div>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">üîã Battery & Current</h4>
                    <div class="chart-container"><canvas id="powerChart"></canvas></div>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">üå°Ô∏è Temperature</h4>
                    <div class="chart-container"><canvas id="tempChart"></canvas></div>
                </div>
                <div class="chart-card">
                    <h4 class="chart-title">üí® Pressure</h4>
                    <div class="chart-container"><canvas id="pressureChart"></canvas></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class RccPlotter {
            constructor() {
                this.locomotives = new Map();
                this.charts = {};
                this.colors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#feca57'];
                this.colorIndex = 0;
                this.isConnected = false;
                this.selectedLocoId = null;
                this.init();
            }

            init() {
                console.log('RCC Plotter initializing...');
                this.setupCharts();
                this.startPolling();
            }

            setupCharts() {
                const commonOptions = {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: true, position: 'top', labels: { boxWidth: 12, font: { size: 11 } } } },
                    scales: {
                        x: { type: 'time', time: { unit: 'second', displayFormats: { second: 'mm:ss' } }, ticks: { maxRotation: 0 } },
                        y: { beginAtZero: true, ticks: { font: { size: 11 } } }
                    },
                    elements: { point: { radius: 0 }, line: { tension: 0.3, borderWidth: 2 } },
                    animation: false,
                    interaction: { intersect: false, mode: 'index' }
                };

                this.charts.speed = new Chart(document.getElementById('speedChart'), {
                    type: 'line', data: { datasets: [] }, options: commonOptions
                });
                this.charts.power = new Chart(document.getElementById('powerChart'), {
                    type: 'line', data: { datasets: [] }, options: commonOptions
                });
                this.charts.temp = new Chart(document.getElementById('tempChart'), {
                    type: 'line', data: { datasets: [] }, options: commonOptions
                });
                this.charts.pressure = new Chart(document.getElementById('pressureChart'), {
                    type: 'line', data: { datasets: [] }, options: commonOptions
                });
            }

            async startPolling() {
                setInterval(() => this.pollData(), 1000);
                this.pollData();
            }

            async pollData() {
                try {
                    await this.checkStatus();
                    await this.getLocoList();
                    for (const [locoId] of this.locomotives) {
                        await this.getTelemetry(locoId);
                    }
                } catch (error) {
                    console.error('Poll error:', error);
                }
            }

            async checkStatus() {
                try {
                    const response = await fetch('/json/memory/RCC_STATUS');
                    const data = await response.json();
                    // JMRI returns single object, not array
                    if (data && data.data) {
                        const status = data.data.value;
                        this.isConnected = (status === 'CONNECTED');
                    }
                } catch (error) {
                    this.isConnected = false;
                }
            }

            async getLocoList() {
                try {
                    const response = await fetch('/json/memory/RCC_LOCO_LIST');
                    const data = await response.json();
                    // JMRI returns single object, not array
                    if (data && data.data && data.data.value) {
                        const locoList = JSON.parse(data.data.value);
                        locoList.forEach(loco => {
                            if (!this.locomotives.has(loco.id)) {
                                this.addLocomotive(loco.id, loco.name, loco.address);
                            }
                        });
                        this.updateLocoDisplay();
                    }
                } catch (error) {
                    console.error('Error getting loco list:', error);
                }
            }

            async getTelemetry(locoId) {
                const metrics = ['speed', 'throttle', 'battery', 'current', 'temp', 'psi', 'distance'];
                const telemetry = {};

                for (const metric of metrics) {
                    try {
                        const response = await fetch(`/json/memory/RCC_${locoId}_${metric.toUpperCase()}`);
                        const data = await response.json();
                        // JMRI returns single object, not array
                        if (data && data.data && data.data.value) {
                            telemetry[metric] = parseFloat(data.data.value);
                        }
                    } catch (error) { }
                }

                if (Object.keys(telemetry).length > 0) {
                    this.updateLocoData(locoId, telemetry);
                }
            }

            addLocomotive(id, name, address) {
                const loco = {
                    id, name: name || `Loco ${id}`, address,
                    color: this.colors[this.colorIndex % this.colors.length],
                    data: { speed: [], throttle: [], battery: [], current: [], temp: [], pressure: [] },
                    distance: 0
                };
                this.locomotives.set(id, loco);
                this.colorIndex++;

                // Auto-select first locomotive
                if (!this.selectedLocoId) {
                    this.selectedLocoId = id;
                    this.addLocoToCharts(loco);
                    this.updateControlPanel();
                }

                console.log('Added locomotive:', loco.name);
            }

            addLocoToCharts(loco) {
                const createDataset = (label, dash = false) => ({
                    label, data: [], borderColor: loco.color,
                    backgroundColor: loco.color + '30', borderDash: dash ? [5, 5] : [],
                    fill: false
                });

                this.charts.speed.data.datasets.push(createDataset(`${loco.name} Speed`));
                this.charts.speed.data.datasets.push(createDataset(`${loco.name} Throttle`, true));
                this.charts.power.data.datasets.push(createDataset(`${loco.name} Battery`));
                this.charts.power.data.datasets.push(createDataset(`${loco.name} Current`, true));
                this.charts.temp.data.datasets.push(createDataset(`${loco.name} Temp`));
                this.charts.pressure.data.datasets.push(createDataset(`${loco.name} Pressure`));
            }

            updateLocoData(locoId, telemetry) {
                const loco = this.locomotives.get(locoId);
                if (!loco) return;

                const now = new Date();
                const maxPoints = 30;

                ['speed', 'throttle', 'battery', 'current', 'temp'].forEach(key => {
                    if (telemetry[key] !== undefined && loco.data[key]) {
                        loco.data[key].push({ x: now, y: telemetry[key] });
                        if (loco.data[key].length > maxPoints) loco.data[key].shift();
                    }
                });

                if (telemetry.psi !== undefined) {
                    loco.data.pressure.push({ x: now, y: telemetry.psi });
                    if (loco.data.pressure.length > maxPoints) loco.data.pressure.shift();
                }

                if (telemetry.distance !== undefined) loco.distance = telemetry.distance;

                // Only update charts if this is the selected locomotive
                if (this.selectedLocoId === locoId) {
                    this.updateCharts(loco);
                }
            }

            updateCharts(loco) {
                const updateDataset = (chart, label, data) => {
                    const ds = chart.data.datasets.find(d => d.label === label);
                    if (ds) ds.data = data;
                };

                updateDataset(this.charts.speed, `${loco.name} Speed`, loco.data.speed);
                updateDataset(this.charts.speed, `${loco.name} Throttle`, loco.data.throttle);
                updateDataset(this.charts.power, `${loco.name} Battery`, loco.data.battery);
                updateDataset(this.charts.power, `${loco.name} Current`, loco.data.current);
                updateDataset(this.charts.temp, `${loco.name} Temp`, loco.data.temp);
                updateDataset(this.charts.pressure, `${loco.name} Pressure`, loco.data.pressure);

                Object.values(this.charts).forEach(chart => chart.update('none'));
            }

            updateLocoDisplay() {
                const list = document.getElementById('locoList');
                if (this.locomotives.size === 0) {
                    list.innerHTML = '<em style="color: #999;">Waiting...</em>';
                    return;
                }

                let html = '';
                this.locomotives.forEach(loco => {
                    const isSelected = this.selectedLocoId === loco.id;
                    const selectedClass = isSelected ? 'selected' : '';
                    html += `
                        <div class="loco-item ${selectedClass}" onclick="plotter.selectLocomotive('${loco.id}')">
                            <span class="loco-color" style="background: ${loco.color}"></span>
                            <span class="loco-name">${loco.name}</span>
                            <div class="loco-details">Address: ${loco.address} ‚Ä¢ Distance: ${loco.distance.toFixed(1)}</div>
                        </div>
                    `;
                });
                list.innerHTML = html;
            }

            selectLocomotive(locoId) {
                this.selectedLocoId = locoId;
                this.updateLocoDisplay();
                this.updateAllCharts();
                this.updateControlPanel();
            }

            async updateControlPanel() {
                const controlsContent = document.getElementById('controlsContent');

                if (!this.selectedLocoId) {
                    controlsContent.innerHTML = '<em style="color: #999;">Select a locomotive</em>';
                    return;
                }

                const loco = this.locomotives.get(this.selectedLocoId);
                if (!loco) return;

                // Fetch current throttle and direction from memory
                let currentThrottle = 0;
                let currentDirection = 'STOP';
                
                try {
                    const throttleResp = await fetch(`/json/memory/RCC_${this.selectedLocoId}_THROTTLE`);
                    const throttleData = await throttleResp.json();
                    if (throttleData && throttleData.data && throttleData.data.value) {
                        currentThrottle = Math.round(parseFloat(throttleData.data.value));
                    }
                } catch (e) { }
                
                try {
                    const dirResp = await fetch(`/json/memory/RCC_${this.selectedLocoId}_DIRECTION`);
                    const dirData = await dirResp.json();
                    if (dirData && dirData.data && dirData.data.value) {
                        currentDirection = dirData.data.value;
                    }
                } catch (e) { }

                controlsContent.innerHTML = `
                    <div class="throttle-container">
                        <div class="throttle-value" id="throttleValue">${currentThrottle}</div>
                        <input type="range" class="throttle-slider" id="throttleSlider" 
                               min="0" max="100" value="${currentThrottle}" orient="vertical"
                               oninput="plotter.setThrottle(this.value)">
                    </div>
                    
                    <div class="direction-buttons">
                        <button class="dir-btn ${currentDirection === 'REVERSE' ? 'active' : ''}" onclick="plotter.setDirection('REVERSE')" title="Reverse">‚ñº</button>
                        <button class="dir-btn ${currentDirection === 'STOP' ? 'active' : ''}" onclick="plotter.setDirection('STOP')" title="Stop">‚ñ†</button>
                        <button class="dir-btn ${currentDirection === 'FORWARD' ? 'active' : ''}" onclick="plotter.setDirection('FORWARD')" title="Forward">‚ñ≤</button>
                    </div>
                `;
            }

            setThrottle(value) {
                document.getElementById('throttleValue').textContent = value;
                if (this.selectedLocoId) {
                    this.sendMQTT(`cab/${this.selectedLocoId}/throttle`, value);
                }
            }



            setDirection(direction) {
                if (this.selectedLocoId) {
                    this.sendMQTT(`cab/${this.selectedLocoId}/direction`, direction);

                    // Update throttle based on direction
                    const slider = document.getElementById('throttleSlider');
                    const currentThrottle = parseInt(slider.value);
                    
                    if (direction === 'STOP') {
                        // Set throttle to 0 when stopping
                        slider.value = 0;
                        this.setThrottle(0);
                    } else if (direction === 'FORWARD' || direction === 'REVERSE') {
                        // If throttle is 0, set to a default value (e.g., 30)
                        if (currentThrottle === 0) {
                            slider.value = 0;
                            this.setThrottle(0);
                        }
                    }

                    // Visual feedback
                    document.querySelectorAll('.dir-btn').forEach(btn => btn.classList.remove('active'));
                    event.target.classList.add('active');
                }
            }

            sendMQTT(topic, payload) {
                // Send MQTT message via JMRI memory variable
                const cmdData = JSON.stringify({ topic, payload, timestamp: Date.now() });
                console.log(`MQTT Command: ${topic} -> ${payload}`);
                
                // JMRI JSON API supports PUT for setting values
                fetch('/json/memory/RCC_CMD', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        type: 'memory',
                        data: {
                            name: 'RCC_CMD',
                            value: cmdData
                        }
                    })
                }).then(response => {
                    if (!response.ok) {
                        console.error('Failed to send command:', response.status);
                    }
                }).catch(err => console.error('Error sending MQTT command:', err));
            }

            updateAllCharts() {
                // Clear all charts
                Object.values(this.charts).forEach(chart => {
                    chart.data.datasets = [];
                });

                // Add only selected locomotive's data
                if (this.selectedLocoId) {
                    const loco = this.locomotives.get(this.selectedLocoId);
                    if (loco) {
                        // Create datasets with existing data
                        const createDataset = (label, data, dash = false) => ({
                            label,
                            data: data || [],
                            borderColor: loco.color,
                            backgroundColor: loco.color + '30',
                            borderDash: dash ? [5, 5] : [],
                            fill: false
                        });

                        this.charts.speed.data.datasets.push(createDataset(`${loco.name} Speed`, loco.data.speed));
                        this.charts.speed.data.datasets.push(createDataset(`${loco.name} Throttle`, loco.data.throttle, true));
                        this.charts.power.data.datasets.push(createDataset(`${loco.name} Battery`, loco.data.battery));
                        this.charts.power.data.datasets.push(createDataset(`${loco.name} Current`, loco.data.current, true));
                        this.charts.temp.data.datasets.push(createDataset(`${loco.name} Temp`, loco.data.temp));
                        this.charts.pressure.data.datasets.push(createDataset(`${loco.name} Pressure`, loco.data.pressure));

                        // Update all charts
                        Object.values(this.charts).forEach(chart => chart.update('none'));
                    }
                }
            }


        }

        // Start the plotter and make it globally accessible
        let plotter;
        document.addEventListener('DOMContentLoaded', () => {
            plotter = new RccPlotter();
        });
    </script>
</body>

</html>